<a href="http://tiny.cc/plm19"><img width=1000 src="https://raw.githubusercontent.com/txt/plm19/master/etc/img/banner.png"></a><br>
&nbsp;<a href="http://tiny.cc/plm19">home</a> |
<a href="https://github.com/txt/plm19/blob/master/doc/syllabus.md">syllabus</a> |
<a href="https://github.com/txt/plm19/tree/master/src">src</a> |
<a href="http://tiny.cc/plm19give">submit</a> |
<a href="https://plm19.slack.com/">chat</a> |
<a href="https://github.com/txt/plm19/blob/master/LICENSE.md">&copy;2019</a> 
by <a href="http://menzies.us">Tim Menzies</a>
'

# Bonus marks for  Project 2

Your mission is to replace N part of my data mining
pipeline with machines of your own making.

For each part replaced, the score will be:

- 10 marks (if there is an initial planning doc, a working
  implementation, and a final epilogue added to the doc)
- plus, at max up to 2 marks bonus for coding the "hard" filter
- plus, at max up to 2 marks bonus for coding in "hard" languages
- plus, at max up to 2 marks bonus for coding in "hard" abstractions
- For a max of 16

Note that for the language and abstractions, your code
will have to show that you have made **extensive** 
and **elaborate** use of those 
abstractions and languages (so a few lines of code over in one corner will **not** earn  you the marks)

## Filter  Bonus Marks


\* monte\_carlo  |  
\*\*\* brooks2 |  
\*    dom  
\*\* bestrest  
\*\*\* super  
\*\* rank  

## Language Bonus Marks


### One star languages (zero bonus marks)

\* D  
\* Dart  
\* Go  
\* Groovy  
\* Java  
\* JavaScript  
\* Lua  
\* Objective-C  
\* PHP  
\* Perl  
\* Python  

### Two star languages (one bonus mark)

\*\* Awk/gawk  
\*\* Bash  
\*\* Fortran  
\*\* Smalltalk (gnu smalltalk, accept no other)
\*\* Kotlin  
\*\* Ruby  
\*\* Rust  
\*\* Swift  

### Three star languages (two bonus marks)

\*\*\* Clojure  
\*\*\* CoffeeScript  
\*\*\* Elixir  
\*\*\* Elm   
\*\*\* Erlang  
\*\*\* Forth  
\*\*\* Haskell  
\*\*\* Julia  
\*\*\* Lisp  
\*\*\* ML  
\*\*\* Prolog  
\*\*\* Scala  
\*\*\* Scheme  
\*\*\* TypeScript  

## Abstraction bonus marks

Note that some of these abstractions we will/have cover(ed) in class.
For the rest, get reading:

- Gof: https://springframework.guru/gang-of-four-design-patterns/
- Lopes: https://github.com/crista/exercises-in-programming-style
- Fowler: https://catalog.lib.ncsu.edu/catalog/NCSU2708437

(For the Fowler book, show me the pattern you want to try and
I'll score it when I see it).

Making extensive use of any one following will earn you **zero**
extra mark:

### One star abstractions (zero bonus marks)

- \* Inheritance
- \* Polymorphism
- \* Delegation
- \* Gof Design patterns (all of them, unless referenced below)

### Two star abstractions (one bonus mark)

- \*\*  Layers (need at least 3 to qualify)
- \*\*  Pattern matching (replacing large hunks of procedural code
  with declarative pattern matching)
- \*\*  Pipe and Filter (not my code but some elaborate filter 
  \*\*  system of your own creation)
- \*\*  State machines
- \*\*  Compartmental models
- \*\*  LetterBox (Lopes, [chp11](https://github.com/crista/exercises-in-programming-style/tree/master/11-letterbox))

### Three star abstractions (two bonus marks)

- \*\*\*  Macros (in Lisp or Julia or Elixr or some other language
  that I must pre-approve) to write your won domain specific
  language. And much of the functionality of the system
  must be written in macros.
- \*\*\*  Interpreter (i.e. right your own specialized domain specific
  language for that task)
- \*\*\*  Lambda calculus (so not just using LISP but going nuts
  on set operatiors implemeted as lambdas mapped over lists)
- \*\*\*  Rule-based programming (lots of match-select-act)
- \*\*\*  Blackboards (agents watching a shared space, trigger on
  conclusions of lower-level agents, writing results to
  higher levels)
- \*\*\*  GoForth (Lopes, [chp2](https://github.com/crista/exercises-in-programming-style/tree/master/02-go-forth))
- \*\*\*  Hollywood (Lopes, [chp14](https://github.com/crista/exercises-in-programming-style/tree/master/14-hollywood))
- \*\*\*  Apsects (Lopes, [chp18](https://github.com/crista/exercises-in-programming-style/tree/master/18-aspects))
- \*\*\*  Tantrum (Lopes, [cp21](https://github.com/crista/exercises-in-programming-style/tree/master/21-tantrum))
- \*\*\*  Quarantime (Lopes, [cp24](https://github.com/crista/exercises-in-programming-style/tree/master/24-quarantine))
- \*\*\* Spreadsheet (Lopes, [cp26](https://github.com/crista/exercises-in-programming-style/tree/master/26-spreadsheet)) aka
  matrix of lambda bodies
- \*\*\*  Lazy Rivers (Lopes, [cp27](https://github.com/crista/exercises-in-programming-style/tree/master/27-lazy-rivers))
- \*\*\*  Map reduce (Lopes, [cp30](https://github.com/crista/exercises-in-programming-style/tree/master/30-map-reduce))
- \*\*\*  Restful (Lopes, [cp33](https://github.com/crista/exercises-in-programming-style/tree/master/33-restful))


